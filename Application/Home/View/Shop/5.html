<!-- <html>
<head>
    <title>xApp</title>
    <script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=K3yDzvlwWbDlvSQyvwCLd0l5"></script>

    <style type="text/css">
        html,body{height:100%;margin:0 auto;}
        #map,#maps{height:100%;width:100%;}
    </style>
</head>
<body>
    <div id="maps"></div>
    <canvas id="map"></canvas>

    <script type="text/javascript" language="javascript">

        var map = new BMap.Map("maps", {});                        // 创建Map实例
        map.centerAndZoom(new BMap.Point(116.404, 39.915), 3);     // 初始化地图,设置中心点坐标和地图级别
        map.enableScrollWheelZoom();                            //启用滚轮放大缩小
        if (document.createElement('canvas').getContext) {
            //var mapStyle = {
            //    features: ["road", "building", "water", "land"],//隐藏地图上的poi
            //    style: "dark"  //设置地图风格为高端黑
            //}
            //map.setMapStyle(mapStyle);


            var canvas;
            // 复杂的自定义覆盖物
            function ComplexCustomOverlay(point) {
                this._point = point;
                this.car = [];
            }
            function Star(x,y,ctx,pt)
            {
                this.bx = this.x = x;
                this.by = this.y = y;
                this.pt = pt;
                this.ctx = ctx;
                this.size = 8;
                if (x == 0 && y == 0) {
                    var b = 3;
                }
                this.render = function(size)
                {
                    var ctx = this.ctx;
                    var p = this;
                    if (p.x == 0 && p.y == 0)
                    {
                        var b = 3;
                    }
                    p.size = size;
                    p.isVisible = false;
                    var x = p.x  , y = p.y ;
                    if (x < 0 || y < 0)
                        return false;
                    if (x > ctx.canvas.width || y > ctx.canvas.height)
                        return false;
                  //  console.log(x, y, ctx.canvas.width, ctx.canvas.height);
                    ctx.beginPath();
                    
                    var gradient = ctx.createRadialGradient(p.x  , p.y , 0, p.x  , p.y  , p.size);
                    gradient.addColorStop(0, "rgba(7,120,249,1)");
                    gradient.addColorStop(1, "rgba(7,120,249,0.3)");
                    ctx.fillStyle = gradient;

                   // ctx.fillRect( p.x  , p.y  , 10, 10);

                    ctx.arc(p.x , p.y , p.size, Math.PI * 2, false);
                    ctx.fill();
                    p.isVisible = true;
                    return true;
                }
            }
            ComplexCustomOverlay.prototype = new BMap.Overlay();
            ComplexCustomOverlay.prototype.initialize = function (map) {
                this._map = map;
                canvas = this.canvas = document.createElement("canvas");
                canvas.style.cssText = "position:absolute;left:0;top:0;";
                ctx = this.ctx = canvas.getContext("2d");
                var size = map.getSize();
                canvas.width = BW = size.width;
                canvas.height = BH = size.height;
                map.getPanes().labelPane.appendChild(canvas);

                this.car.length = 0;

                var bound = map.getBounds();
                var project = map.getMapType().getProjection();
                var sw = bound.getSouthWest();
                var ne = bound.getNorthEast();
                var lat = ne.lat - sw.lat;
                var lng = ne.lng - sw.lng;
                for (var i = 0; i < 5000; i++) {
                    // var pt = project.lngLatToPoint();
                    var p = new BMap.Point(Math.random() * lng + (sw.lng), Math.random() * lat + (sw.lat));
                  //  var py = map.pointToOverlayPixel(p);
                    var py = project.lngLatToPoint(p);
                    this.car.push(new Star(py.x, py.y, ctx,p));
                }

                var p = this;
                canvas.addEventListener('click', function (a, b) {
                    for (var i = 0; i < p.car.length; i++)
                    {
                        var c = p.car[i];
                        var x = a.clientX;
                        var y = a.clientY;
                        var s = c.size ;

                        if (p.isVisible && Math.abs(c.x-x) < s && Math.abs(c.y-y) < s )
                        {
                            alert('ok');
                            return;
                        }

                    }
                    
                });
                canvas.addEventListener('mousemove', function (a, b) {
                    for (var i = 0; i < p.car.length; i++) {
                        var c = p.car[i];
                        var x = a.clientX;
                        var y = a.clientY;
                        var s = c.size;

                        if (p.isVisible && Math.abs(c.x - x) < s && Math.abs(c.y - y) < s) {
                            canvas.style.cursor = 'pointer';
                            return;
                        }
                    }
                    if (canvas.style.cursor != '')
                        canvas.style.cursor = '';
                });
                var resize = function () {
                    var size = map.getSize();
                  //  var canvas = canvas;
                    var pixelRatio;

                   {
                        pixelRatio = (function (context) {
                            var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;

                            return (window.devicePixelRatio || 1) / backingStore;
                        })(canvas.getContext('2d'));
                    }

                    canvas.width = size.width * pixelRatio;
                    canvas.height = size.height * pixelRatio;
                    canvas.style.width = size.width + "px";
                    canvas.style.height = size.height + "px";
                    p.draw();
                };
                map.addEventListener('resize', function () {
                    resize();
                });
                //map.getContainer().appendChild(canvas);
                return this.canvas;
            }
            ComplexCustomOverlay.prototype.draw = function () {
                var map = this._map;
                var bounds = map.getBounds();
                var sw = bounds.getSouthWest();
                var ne = bounds.getNorthEast();
                var project = map.getMapType().getProjection();
                var pixel2 = project.lngLatToPoint(new BMap.Point(sw.lng, sw.lat));
                var pixel3 = project.lngLatToPoint(new BMap.Point(ne.lng, ne.lat));
              // pixel = map.pointToPixel(new BMap.Point(sw.lng, ne.lat));
                var size = map.getSize();
                var center = map.getCenter();
                if (center) {
                   var pixel = map.pointToOverlayPixel(center);
                    this.canvas.style.left = pixel.x - size.width / 2 + 'px';
                    this.canvas.style.top = pixel.y - size.height / 2 + 'px';

                }
                var py = pixel;
                // 墨卡托坐标计算方法
                var zoom = map.getZoom();
                var zoomUnit = Math.pow(2, 18 - zoom);
                var mcCenter = project.lngLatToPoint(map.getCenter());
                var nwMc = new BMap.Pixel(mcCenter.x - map.getSize().width / 2 * zoomUnit, mcCenter.y + map.getSize().height / 2 * zoomUnit); //左上角墨卡托坐标
                pixel2.x = (pixel2.x - nwMc.x) / zoomUnit;
                pixel2.y = (nwMc.y - pixel2.y) / zoomUnit;

                pixel3.x = (pixel3.x - nwMc.x) / zoomUnit;
                pixel3.y = (nwMc.y - pixel3.y) / zoomUnit;

                for (var i = 0; i < this.car.length; i++) {
                    var c = this.car[i];
                    //var pt = project.lngLatToPoint(c.pt);
                    if (c.pt && (!c.by || !c.bx))
                    {
                        var pixel = project.lngLatToPoint(c.pt);
                        c.bx = pixel.x;
                        c.by = pixel.y;
                    }
                    if (c.bx && c.by) {
                        c.x = (c.bx - nwMc.x) / zoomUnit;
                        c.y = (nwMc.y - c.by) / zoomUnit;
                        if ( c.x == 0 && c.y == 0 )
                        {
                            var a;
                        }
                    }
                    //var lg = project.pointToLngLat(new BMap.Pixel());
                    //var px = map.pointToOverlayPixel(c.pt);
                    //c.x = px.x - py.x;
                    //c.y = px.y - py.y;
                }
                
                //if (rs.length > 0) {
                //    showStars(rs);
                //}
                
              //  this.canvas.style.left = py.x + 'px';
              //  this.canvas.style.top = py.y + 'px';
                this.canvas.style.opacity = 0.8;

                this.ctx.clearRect(0, 0, map.getSize().width, map.getSize().height);
                this.ctx.fillRect(0, 0, map.getSize().width, map.getSize().height);

                this.ctx.globalCompositeOperation = "lighter";
                
                if ( this.car.length > 0 )
                {
                    var dcar = [];
                    for(var i = 0; i<this.car.length; i++)
                    {
                        c = this.car[i];
                        if (c.x == 0 && c.y == 0)
                            continue;
                      //  if (c.x > pixel3.x || c.y > pixel3.y || c.x < pixel2.x || c.y < pixel2.y)
                      //      continue;
                        if (this.car[i].render(4))
                            dcar.push(this.car[i]);
                    }
                    if ( dcar.length < 100 )
                    {
                        for(var i=0; i<dcar.length; i++)
                        {
                            dcar[i].render(10);
                        }
                    }
                }
            }
            var myCompOverlay = new ComplexCustomOverlay(new BMap.Point(0.407845, 0.914101));
            map.addOverlay(myCompOverlay);
            map.addEventListener('click', function (a, b) {
                console.log(a, b);
            })
        }
    </script>
</body>
</html>

 <!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html,#allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
    </style>
    <script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=wqBXfIN3HkpM1AHKWujjCdsi"></script>
    <title>多个标注点沿折线的轨迹运动</title>
</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    // 百度地图API功能
    var map = new BMap.Map("allmap");
    map.centerAndZoom(new BMap.Point(116.404, 39.915), 15);
    var bounds = null;
    var linesPoints = null;
    var spoi1 = new BMap.Point(116.380967,39.913285);    // 起点1
    var spoi2 = new BMap.Point(116.380967,39.953285);    // 起点2
    var epoi  = new BMap.Point(116.424374,39.914668);    // 终点
    var myIcon = new BMap.Icon("http://developer.baidu.com/map/jsdemo/img/Mario.png", new BMap.Size(32, 70), {imageOffset: new BMap.Size(0, 0)});
    function initLine(){
        bounds = new Array();
        linesPoints = new Array();
        map.clearOverlays();                                                    // 清空覆盖物
        var driving3 = new BMap.DrivingRoute(map,{onSearchComplete:drawLine});  // 驾车实例,并设置回调
            driving3.search(spoi1, epoi);                                       // 搜索一条线路
        var driving4 = new BMap.DrivingRoute(map,{onSearchComplete:drawLine});  // 驾车实例,并设置回调
            driving4.search(spoi2, epoi);                                       // 搜索一条线路
    }
    function run(){
        for(var m = 0;m < linesPoints.length; m++){
            var pts = linesPoints[m];
            var len = pts.length;
            var carMk = new BMap.Marker(pts[0],{icon:myIcon});
            map.addOverlay(carMk);
            resetMkPoint(1,len,pts,carMk)
        }
        
        function resetMkPoint(i,len,pts,carMk){
            carMk.setPosition(pts[i]);
            if(i < len){
                setTimeout(function(){
                    i++;
                    resetMkPoint(i,len,pts,carMk);
                },100);
            }
        }
        
    }
    function drawLine(results){
        var opacity = 0.45;
        var planObj = results.getPlan(0);
        var b = new Array();
        var addMarkerFun = function(point,imgType,index,title){
            var url;
            var width;
            var height
            var myIcon;
            // imgType:1的场合，为起点和终点的图；2的场合为车的图形
            if(imgType == 1){
                url = "http://developer.baidu.com/map/jsdemo/img/dest_markers.png";
                width = 42;
                height = 34;
                myIcon = new BMap.Icon(url,new BMap.Size(width, height),{offset: new BMap.Size(14, 32),imageOffset: new BMap.Size(0, 0 - index * height)});
            }else{
                url = "http://developer.baidu.com/map/jsdemo/img/trans_icons.png";
                width = 22;
                height = 25;
                var d = 25;
                var cha = 0;
                var jia = 0
                if(index == 2){
                    d = 21;
                    cha = 5;
                    jia = 1;
                }
                myIcon = new BMap.Icon(url,new BMap.Size(width, d),{offset: new BMap.Size(10, (11 + jia)),imageOffset: new BMap.Size(0, 0 - index * height - cha)});
            }
            
            var marker = new BMap.Marker(point, {icon: myIcon});
            if(title != null && title != ""){
                marker.setTitle(title);
            }
            // 起点和终点放在最上面
            if(imgType == 1){
                marker.setTop(true);
            }
            map.addOverlay(marker);
        }
        var addPoints = function(points){
            for(var i = 0; i < points.length; i++){
                bounds.push(points[i]);
                b.push(points[i]);
            }
        }   
        // 绘制驾车步行线路
        for (var i = 0; i < planObj.getNumRoutes(); i ++){
            var route = planObj.getRoute(i);
            if (route.getDistance(false) <= 0){continue;}
            addPoints(route.getPath());
            // 驾车线路
            if(route.getRouteType() == BMAP_ROUTE_TYPE_DRIVING){
                map.addOverlay(new BMap.Polyline(route.getPath(), {strokeColor: "#0030ff",strokeOpacity:opacity,strokeWeight:6,enableMassClear:true}));
            }else{
            // 步行线路有可能为0
                map.addOverlay(new BMap.Polyline(route.getPath(), {strokeColor: "#30a208",strokeOpacity:0.75,strokeWeight:4,enableMassClear:true}));
            }
        }   
        map.setViewport(bounds);    
        // 终点
        addMarkerFun(results.getEnd().point,1,1);
        // 开始点
        addMarkerFun(results.getStart().point,1,0);
        linesPoints[linesPoints.length] = b;
    }
    initLine();
    setTimeout(function(){
        run();
    },1500);
</script>
 <!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html,#allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:"微软雅黑";}
    </style>
    <script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=K3yDzvlwWbDlvSQyvwCLd0l5"></script>
    <title>单个标注点沿直线的轨迹运动</title>
</head>
<body>
    <div id="allmap"></div>
</body>
</html>
<script type="text/javascript">
    // 百度地图API功能
    var map = new BMap.Map("allmap");
    map.centerAndZoom(new BMap.Point(116.404, 39.915), 15);

    var myP1 = new BMap.Point(116.380967,39.913285);    //起点
    var myP2 = new BMap.Point(116.424374,39.914668);    //终点
    var myIcon = new BMap.Icon("http://developer.baidu.com/map/jsdemo/img/Mario.png", new BMap.Size(32, 70), {    //小车图片
        //offset: new BMap.Size(0, -5),    //相当于CSS精灵
        imageOffset: new BMap.Size(0, 0)    //图片的偏移量。为了是图片底部中心对准坐标点。
      });
    var driving2 = new BMap.DrivingRoute(map, {renderOptions:{map: map, autoViewport: true}});    //驾车实例
    driving2.search(myP1, myP2);    //显示一条公交线路

    window.run = function (){
        var driving = new BMap.DrivingRoute(map);    //驾车实例
        driving.search(myP1, myP2);
        driving.setSearchCompleteCallback(function(){
            var pts = driving.getResults().getPlan(0).getRoute(0).getPath();    //通过驾车实例，获得一系列点的数组
            var paths = pts.length;    //获得有几个点

            var carMk = new BMap.Marker(pts[0],{icon:myIcon});
            map.addOverlay(carMk);
            i=0;
            function resetMkPoint(i){
                carMk.setPosition(pts[i]);
                if(i < paths){
                    setTimeout(function(){
                        i++;
                        resetMkPoint(i);
                    },100);
                }
            }
            setTimeout(function(){
                resetMkPoint(5);
            },100)

        });
    }

    setTimeout(function(){
        run();
    },1500);
</script>
 -->

 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>百度地图</title>
<style type="text/css">
html{height:100%}
body{height:100%;margin:0px;padding:0px}
#container{height:100%}
</style>
<script type="text/javascript" src="http://api.map.baidu.com/api?v=1.3"></script>
</head>

<body>
<div id="container"></div>
<script type="text/javascript">
localSearch();
deploySearch();
rimSearch();
boundsSearch();
busLine();
//drivingLine();

//根据关键这搜索区域
function localSearch(){
var map = new BMap.Map("container"); // 创建地图实例
map.addControl(new BMap.NavigationControl());//地图控制插件，该插件可以控制地图的位置地图的显示比例
map.addControl(new BMap.ScaleControl());//显示在地图下方，告诉你地图上1cm对应的真实距离
//map.addControl(new BMap.OverviewMapControl());
map.addControl(new BMap.MapTypeControl());//地图的显示类型：包括地图和卫星
//确定搜索对象
var local=new BMap.LocalSearch(map,{
renderOptions:{map:map}
});
//根据关键字定义到相应的区域
local.search("南京");
}

//搜索北京市里的中关村,只显示8个结果
function deploySearch(){
var map=new BMap.Map("container");
map.addControl(new BMap.NavigationControl());
var local=new BMap.LocalSearch("北京市",{
renderOptions:{
map:map,
autoViewport:true,
selectFirstResult:true
},
pageCapacity:8
});
local.search("中关村");
}

//在南京玄武湖附近搜索小吃
function rimSearch(){
var map = new BMap.Map("container"); 
var point = new BMap.Point(118.783557,32.053502); // 创建点坐标
map.centerAndZoom(point,15); // 初始化地图，设置初始点为南京
map.addControl(new BMap.NavigationControl()); 
var local = new BMap.LocalSearch(map, { 
renderOptions:{map: map, autoViewport: true} 
}); 
local.searchNearby("小吃", "玄武湖"); 
}

//当前地图视野范围内搜索银行
function boundsSearch(){
var map = new BMap.Map("container"); 
//地点为北京
map.centerAndZoom(new BMap.Point(116.404, 39.915), 14); 
map.addControl(new BMap.NavigationControl());
var local = new BMap.LocalSearch(map, { 
renderOptions:{map: map} 
}); 
//搜索地图视野内的银行
local.searchInBounds("银行", map.getBounds()); 
}

//公交导航的区域范围只能是市，下面是南京市天隆寺到玄武湖的公交路线
function busLine(){
var map = new BMap.Map("container"); 
//地点为南京
map.centerAndZoom(new BMap.Point(118.783557,32.053502), 14); 
map.addControl(new BMap.NavigationControl());
var transit = new BMap.TransitRoute(map, { 
renderOptions: {map: map} 
}); 
transit.search("天隆寺", "玄武湖"); 
}

//南京从天隆寺到玄武湖驾车路线
function drivingLine(){
var map = new BMap.Map("container"); 
//地点为南京
map.centerAndZoom(new BMap.Point(118.783557,32.053502), 14); 
map.addControl(new BMap.NavigationControl());
var driving = new BMap.DrivingRoute(map, { 
renderOptions: { 
map: map, 
autoViewport: true 
} 
}); 
driving.search("天隆寺", "玄武湖");
}
</script>
</body>
</html>